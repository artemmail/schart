# Анализ FootPrintComponent

## Краткое описание текущей логики
- Компонент проксирует входные параметры (`params`, `presetIndex`, режимы и postInit) во внутренний `FootprintStateService`, после каждого обновления проверяя готовность данных и триггеря инициализацию вида через `initializeViewIfReady`.【F:Angular/mat/src/app/components/footprint/footprint.component.ts†L42-L212】【F:Angular/mat/src/app/components/footprint/footprint.component.ts†L445-L481】
- В `ngAfterViewInit` компонент инициализирует canvas, создаёт менеджеры взаимодействия (`MouseAndTouchManager`, `ViewsManager`, `MarkUpManager`), помечает состояние как готовое и запускает первичную инициализацию вида.【F:Angular/mat/src/app/components/footprint/footprint.component.ts†L405-L424】
- Перестройка представления выполняется цепочкой `initSize()` → `resize()` → `drawClusterView()`: `initSize` выравнивает canvas, обновляет layout, создаёт матрицу через `FootprintLayoutService`, запускает отрисовку и postInit-хук; `resize` дергается как обработчик window:resize; `drawClusterView` напрямую вызывает `ViewsManager`. Эта цепочка вызывается из `applySettings`, `applyData` и `initializeViewIfReady`.【F:Angular/mat/src/app/components/footprint/footprint.component.ts†L352-L481】
- Компонент также инкапсулирует вспомогательные операции: экспорт CSV, управление подсказками, расчёт геометрии кластера, работу с deltaVolumes и реагирование на realtime-обновления (merge матриц и перерисовка).【F:Angular/mat/src/app/components/footprint/footprint.component.ts†L155-L263】【F:Angular/mat/src/app/components/footprint/footprint.component.ts†L302-L350】【F:Angular/mat/src/app/components/footprint/footprint.component.ts†L483-L494】

## Оценка необходимости рефакторинга
- **Высокая связность и множество ролей.** Компонент одновременно держит ссылки на менеджеры ввода/вёрстки, вычисляет матричную геометрию (`mergeMatrix`, `getMinMaxIndex`, helpers для rect/font), управляет подсказками и экспортом. Это смешивает рисование, логику состояния и вспомогательные сценарии в одном классе.【F:Angular/mat/src/app/components/footprint/footprint.component.ts†L155-L293】【F:Angular/mat/src/app/components/footprint/footprint.component.ts†L352-L399】【F:Angular/mat/src/app/components/footprint/footprint.component.ts†L483-L494】
- **Повторяемость пайплайна и рисков двойной отрисовки.** Один и тот же оркестр (`initSize` → `resize` → `drawClusterView`) вызывается из трёх методов (`applySettings`, `applyData`, `initializeViewIfReady`), причём `initSize` уже вызывает `drawClusterView` и postInit, а затем `resize` и последующие вызовы снова перерисовывают. Это усложняет контроль порядка вызовов и может давать лишние рендеры при каждом изменении входов.【F:Angular/mat/src/app/components/footprint/footprint.component.ts†L352-L481】
- **Свободный доступ к внутренним полям.** Множество свойств (`viewsManager`, `mouseAndTouchManager`, вспомогательные матричные поля) остаются публичными, хотя используются только внутри, что не фиксирует инварианты и усложняет дальнейшую декомпозицию на сервисы/директивы.【F:Angular/mat/src/app/components/footprint/footprint.component.ts†L58-L141】【F:Angular/mat/src/app/components/footprint/footprint.component.ts†L352-L399】

**Вывод:** рефакторинг оправдан — стоит изолировать расчёты и вспомогательные сценарии в сервисы/подкомпоненты и унифицировать пайплайн перерисовки, чтобы снизить связность и убрать дублирование.

## Соответствие требованию слабосвязных модулей
- **Оркестрация частично вынесена в Widget, но renderer остаётся активным участником.** `FootprintWidgetComponent` отвечает за загрузку/обновление данных и подписки SignalR через отдельные сервисы, после чего делегирует `applyData`, `applySettings`, `applyParams` и realtime-ивенты в `FootPrintComponent`. Однако сам `FootPrintComponent` по-прежнему инициирует пайплайн перерисовки (`initSize`/`resize`/`drawClusterView`) после каждого входящего сигнала и самостоятельно управляет postInit-хуком, что делает его не только «renderer», но и инициатором обновлений вида.【F:Angular/mat/src/app/components/footprint/footprint-widget.component.ts†L71-L153】【F:Angular/mat/src/app/components/footprint/footprint.component.ts†L405-L481】
- **Менеджер данных и realtime существуют, но жёстко связаны с renderer.** `FootprintDataLoaderService` и `FootprintRealtimeUpdaterService` корректно разделяют загрузку диапазона, пресеты и подписки SignalR, однако realtime-апдейты обрабатываются внутри data loader через мутацию текущего `ClusterData`, а затем напрямую пушатся в `FootPrintComponent`. Нет промежуточного «данного менеджера», который бы отдавал уже агрегированное состояние/команды, поэтому renderer знает о структуре данных и объединении матриц (`handleRealtimeUpdate` вызывает `mergeMatrix`).【F:Angular/mat/src/app/components/footprint/footprint-data-loader.service.ts†L18-L115】【F:Angular/mat/src/app/components/footprint/footprint-realtime-updater.service.ts†L13-L118】【F:Angular/mat/src/app/components/footprint/footprint.component.ts†L231-L292】【F:Angular/mat/src/app/components/footprint/footprint.component.ts†L447-L494】
- **Сервисы настроек и параметров не изолированы.** Параметры и настройки проксируются из widget в renderer через `applyParams`/`applySettings`, а `FootprintStateService` лишь хранит снапшот. Widget получает `settings$`/`params$` из data loader, но renderer всё равно рассчитывает матрицы и применяет настройки к layout самостоятельно, вместо получения уже подготовленных команд/стейтов для отрисовки. Это затрудняет независимое управление сервисами параметров/настроек и нарушение требования «FootPrintComponent не должен сам ничего инициировать».【F:Angular/mat/src/app/components/footprint/footprint-data-loader.service.ts†L41-L115】【F:Angular/mat/src/app/components/footprint/footprint.component.ts†L352-L399】

**Главные пробелы относительно целевой архитектуры:** renderer остаётся координатором (сам запускает пайплайн и решает, когда выравнивать матрицу и перерисовывать), а обработка realtime и настроек происходит внутри него и data loader без явного слоя команд для отрисовки. Для соответствия требованию стоит ввести отдельный «data/view orchestrator», который будет готовить состояния и триггерить команды draw, оставляя `FootPrintComponent` чистым исполнителем.

## Предлагаемые направления рефакторинга
1. **Единый оркестратор обновлений.** Сконцентрировать вызовы `initSize`, `resize` и `drawClusterView` в одном методе/сервисе и дергать его из `applySettings`, `applyData` и `initializeViewIfReady`, чтобы исключить повторные рендеры и расхождения порядка вызовов.【F:Angular/mat/src/app/components/footprint/footprint.component.ts†L352-L481】
2. **Декомпозиция вспомогательных задач.** Вынести управление подсказками/экспортом/дельта-объёмами в специализированные сервисы или директивы, оставив компоненту только координацию отображения и передачу состояния в `ViewsManager`/`FootprintLayoutService`. Это позволит скрыть внутренние поля и сократить публичное API.【F:Angular/mat/src/app/components/footprint/footprint.component.ts†L155-L293】【F:Angular/mat/src/app/components/footprint/footprint.component.ts†L483-L494】
3. **Чёткие границы и видимость.** Сделать служебные поля и менеджеры приватными, предоставляя только необходимые хелперы через методы/сервис `FootprintStateService`, чтобы инкапсулировать инварианты и уменьшить риски побочных эффектов при внешнем доступе.【F:Angular/mat/src/app/components/footprint/footprint.component.ts†L58-L212】【F:Angular/mat/src/app/components/footprint/footprint.component.ts†L352-L399】
